[
{
	"uri": "//localhost:1313/vi/5-devsecops/5.1-ops-repo/",
	"title": "Cấu hình GitHub Repository (Ops Repo)",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/1-introduce/",
	"title": "Đặt vấn đề",
	"tags": [],
	"description": "",
	"content": "Tại sao là Microservice? Trước khi tìm hiểu về Microservice, ta cần tìm hiểu về cách triển khai production truyền thống: Monolithic. Monolithic là cách ‘đóng gói’ (hay còn gọi là containerize) phần mềm thành một khối duy nhất và triển khai nó lên server. Công nghệ containerize phổ biến mà bạn đọc có thể nghe đến tiêu biểu là Docker. Tưởng tượng phần mềm của bạn được containerized thành một khối duy nhất (hay còn gọi là Image) và đã được triển khai lên server. Bây giờ, một tính năng mới đã được phát triển và sẵn sàng triển khai trên môi trường production. Quá trình update phần mềm sẽ được diễn ra như hình bên dưới.\nNhư bạn đọc có thể thấy, application bắt buộc phải bị tắt, sau đó, phiên bản mới nhất sẽ được khởi chạy. Lúc này đồng nghĩa với việc End User sẽ phải đối diện với downtime vì rõ ràng, phần mềm được ‘đóng gói’ thành một khối duy nhất và update một chức năng cũ lại ảnh hưởng cả tập thể. Tất nhiên, vấn đề này có thể giải quyết bằng các Deployment Strategy như Blue/Green Deployment, etc.\nTuy nhiên, có một kiến trúc phần mềm có thể giải quyết bài toán này: Microservice. Nôm na, Microservice sẽ chia các chức năng (Service) trong Application thành các khối khác nhau và chúng giao tiếp với nhau thông qua các chuẩn giao tiếp như REST, v.v. Việc cập nhật một service sẽ không ảnh hưởng đến các service khác như hình bên dưới.\nTriển khai một ứng dụng Microservice trên Kubernetes (K8s) là một bài toán tiêu biểu. Lúc này ta cần triển khai hạ tầng, và cấu hình cho cụm K8s đòi hỏi sự hợp tác của Team Vận hành (hay Ops Team bao gồm các system engineer, system administrator, network engineer, etc.). Ta có GitOps sẽ là câu trả lời để đảm bảo sự phối hợp đó.\nTại sao là GitOps? Tại sao là DevSecOps? DevOps đã tối ưu hoá quy trình phát triển phần mềm bằng việc ứng dụng các công cụ automation và làm giảm thiểu thời gian ‘release’ sản phẩm. Từ đó, end users và đội ngũ phát triển sẽ được lợi, khi đó:\nEnd user sẽ được cập nhật phiên bản mới nhất của sản phẩm một các nhanh chóng Đội ngũ phát triển sẽ tập trung vào công việc phát triển phần mềm, khi những công đoạn thủ công như: kiểm thử, containerize, etc. đã được tự động hoá.\nTuy nhiên, trong quá trình automation đó, liệu ta có muốn kiểm thử những lỗ hổng bảo mật của source code, built image, hay chính production của chúng ta một cách tự động? Và thế là DevSecOps ra đời để giải quyết những bài toán đó. Trong khuôn khổ của bài Workshop này, chúng ta sẽ triển khai các phương pháp kiểm thử trong DevSecOps như:\nSAST (Static Application Security Testing): thực hiện kiểm thử source code trước khi ‘release’. Ví dụ, nếu ứng dụng của bạn được viết bằng Python, ta sẽ kiểm thử các lỗ hổng bảo mật có thể xuất hiện trên Source Code Python của ta.\nImage Scan và Secure IaC: Tương tự như scan source code cho application, ta cũng sẽ thực hiện scan source code cho hạ tầng (Ví dụ: Liệu hạ tầng cloud của ta có cho phép public access không?) và built image (ví dụ: Image Base của ta có outdated không?).\nDAST (Dynamic Application Security Testing): thực hiện kiểm thử production của chúng ta (Ví dụ: Khi end user gửi một request đến production, liệu có những response không mong muốn nào được trả về không?)\nMonitoring có cần thiết không? Tưởng tượng bạn đọc là một thành viên trong team Dev và Application của chúng ta được triển khai trên cụm Kubernetes. Một khi có lỗi xảy ra ở Application, bạn phải biết cách truy cập vào cụm K8s để xem logs và debug. Nhưng rõ ràng, ta không muốn điều đó xảy ra tí nào vì K8s rất phức tạp, và thế ta cần centralized các logs tại một nơi và developer có thể dễ dàng truy cập cho việc debug. Với bài Workshop này, ta sẽ ứng dụng EFK Stack. Khi đó, Developers sẽ biết được logs thông qua web browser.\nTrong bài Workshop này, chúng ta sẽ tận dụng các dịch vụ từ AWS để giải quyết bài toán trên:\nEC2: Elastic Kubernetes Service: "
},
{
	"uri": "//localhost:1313/vi/2-vpc-ec2/2.2-jump-jenkins-sonar/2.2.1-key/",
	"title": "Tạo cặp Public và Private Key ở Local Machine",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/3-eks/3.1-eks-role/",
	"title": "Tạo Role cho EKS Cluster",
	"tags": [],
	"description": "",
	"content": "\nSSH Agent Forwading Như Architecture ở trên, ta có thể kết nối đến những EC2 Cluster thông qua Bastion Host. Tuy nhiên, ta không hề mong muốn Bastion Host chứa Private Key. Và thế là ta dùng SSH Agent Forwarding. Tại folder có chứa public key mà ta vừa tạo ở phần trước, thực hiện câu lệnh:\nssh-add EC2.pem Sau đó ta có thể kết nối với Bastion Host thông qua câu lệnh:\nssh -A ubuntu@\u0026lt;your-bastion-host-public-IP\u0026gt; Giờ ta đã kết nối thành công với Bastion Host. Giờ ta có thể kết nối đến EC2 Cluster thông qua câu lệnh sau:\nssh ec2-user@\u0026lt;your-EC2Cluster-private-IP\u0026gt; Kiểm tra Scaling Quay trở lại với Bastion Host, ta sẽ dùng Bastion Host để kiểm tra độ Scaling của các EC2 Cluster. Tất nhiên đây không phải là chức năng chính của Bastion Host, nhưng vì thuận tiện nên bạn đọc có thể dùng Bastion Host để gởi request đến Load Balancer và kiểm tra độ Scaling của EC2 Cluster.\n"
},
{
	"uri": "//localhost:1313/vi/2-vpc-ec2/2.1-vpc/2.1.1-createvpc/",
	"title": "Tạo VPC, Internet Gateway, và NAT Gateway",
	"tags": [],
	"description": "",
	"content": "Tạo VPC Tạo Internet Gateway Tạo NAT Gateway "
},
{
	"uri": "//localhost:1313/vi/4-cicd/4.1-application/",
	"title": "Tổng quan Application",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/",
	"title": "Triển khai DevSecOps và ứng dụng GitOps trong CI/CD Pipeline cho ứng dụng Microservice trên AWS EKS",
	"tags": [],
	"description": "",
	"content": "Triển khai DevSecOps và ứng dụng GitOps trong CI/CD Pipeline cho ứng dụng Microservice trên AWS EKS Tổng quan Trong bài Workshop này, bạn đọc sẽ tìm hiểu cách thức tích hợp DevSecOps và ứng dụng GitOps vào CI/CD Pipeline cho một ứng dụng Microservice được triển khai trên Amazon Elastic Kubernetes (EKS). Bạn đọc sẽ bắt đầu việc triển khai hạ tầng trên AWS bằng Terraform, triển khai CI/CD Pipeline, và cuối cùng tích hợp các phương pháp bảo mật trong DevOps, hay còn gọi là DevSecOps.\nKỳ vọng Nội dung "
},
{
	"uri": "//localhost:1313/vi/2-vpc-ec2/2.1-vpc/",
	"title": "Triển khai VPC",
	"tags": [],
	"description": "",
	"content": "Nội dung Tạo VPC, Internet Gateway, và NAT Gateway Tạo Subnet và Subnet Association Chạy Terraform để triển khai hạ tầng Sau khi hoàn thành phần này, hình bên dưới sẽ là hạ tầng của chúng ta:\n"
},
{
	"uri": "//localhost:1313/vi/4-cicd/4.2-jenkins/",
	"title": "Cấu hình Jenkins Server",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/5-devsecops/5.2-sonar/",
	"title": "Cấu hình SonarQube Server",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/2-vpc-ec2/2.2-jump-jenkins-sonar/2.2.2-jump-host/",
	"title": "Tạo Jump Host",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/2-vpc-ec2/2.2-jump-jenkins-sonar/",
	"title": "Tạo Jump Host, Jenkins, và Sonarqube Server",
	"tags": [],
	"description": "",
	"content": "Nội dung Tạo cặp Public và Private Key ở Local Machine Tạo Jump Host Tạo Jenkins Server Tạo SonarQube Server Chạy Terraform để triển khai hạ tầng Sau khi hoàn thành phần này, hình bên dưới sẽ là hạ tầng của chúng ta:\n"
},
{
	"uri": "//localhost:1313/vi/3-eks/3.2-eks-worker-role/",
	"title": "Tạo Role cho EKS Worker Node",
	"tags": [],
	"description": "",
	"content": "Nội dung: Gửi 100.000 requests đến Load Balancer Gửi 1.000.000 requests đến Load Balancer Scale up Desired Task "
},
{
	"uri": "//localhost:1313/vi/2-vpc-ec2/2.1-vpc/2.1.2-create-subnet/",
	"title": "Tạo Subnet và Subnet Association",
	"tags": [],
	"description": "",
	"content": "Tạo Subnet Subnet Association "
},
{
	"uri": "//localhost:1313/vi/2-vpc-ec2/",
	"title": "Triển khai VPC và Jenkins, SonarQube Server",
	"tags": [],
	"description": "",
	"content": "\rBạn đọc cần cài đặt Terraform trước khi có thể hoàn thành bài Workshop này\nTrong phần này, chúng ta sẽ triển khai một VPC với:\n3 Availability Zones 3 Public Subnets 3 Private Subnets 1 Internet Gateway 1 NAT Gateway 3 EC2, trong đó: 1 Jump Host để tương tác với cụm K8s ở private subnet 1 Jenkins Server để triển khai CI pipeline 1 SonarQube Server trong quy trình DevSecOps Nội dung Triển khai VPC Tạo Jump Host, Jenkins Server, và SonarQube Server "
},
{
	"uri": "//localhost:1313/vi/4-cicd/4.3-dev-repo/",
	"title": "Cấu hình GitHub Repository (Dev Repo)",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/5-devsecops/5.3-jenkins/",
	"title": "Cấu hình Jenkins Server",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/2-vpc-ec2/2.1-vpc/2.1.3-run-terraform/",
	"title": "Chạy Terraform để triển khai hạ tầng",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/3-eks/3.3-eks-create/",
	"title": "Tạo EKS Cluster",
	"tags": [],
	"description": "",
	"content": "\nSSH Agent Forwading Như Architecture ở trên, ta có thể kết nối đến những EC2 Cluster thông qua Bastion Host. Tuy nhiên, ta không hề mong muốn Bastion Host chứa Private Key. Và thế là ta dùng SSH Agent Forwarding. Tại folder có chứa public key mà ta vừa tạo ở phần trước, thực hiện câu lệnh:\nssh-add EC2.pem Sau đó ta có thể kết nối với Bastion Host thông qua câu lệnh:\nssh -A ubuntu@\u0026lt;your-bastion-host-public-IP\u0026gt; Giờ ta đã kết nối thành công với Bastion Host. Giờ ta có thể kết nối đến EC2 Cluster thông qua câu lệnh sau:\nssh ec2-user@\u0026lt;your-EC2Cluster-private-IP\u0026gt; Kiểm tra Scaling Quay trở lại với Bastion Host, ta sẽ dùng Bastion Host để kiểm tra độ Scaling của các EC2 Cluster. Tất nhiên đây không phải là chức năng chính của Bastion Host, nhưng vì thuận tiện nên bạn đọc có thể dùng Bastion Host để gởi request đến Load Balancer và kiểm tra độ Scaling của EC2 Cluster.\n"
},
{
	"uri": "//localhost:1313/vi/2-vpc-ec2/2.2-jump-jenkins-sonar/2.2.3-jenkins/",
	"title": "Tạo Jenkins Server",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/3-eks/",
	"title": "Triển khai Kubernetes Cluster",
	"tags": [],
	"description": "",
	"content": "Tại phần này, ta sẽ triển khai cụm Kubernetes Cluster, cũng chính là nơi mà application sẽ được deployed. Thêm vào đó, ta cũng sẽ tạo Elastic Container Registry, nơi đây sẽ chứa các built image của chúng ta.\nKết thúc phần này, ta sẽ có hoàn chỉnh phần Infrastructure, việc còn lại là triển khai CI/CD Pipeline và DevSecOps. Hình bên dưới sẽ là hạ tầng của chúng ta sau khi hoàn thành phần này.\nNội dung Tạo Role cho EKS Cluster Tạo Role cho EKS Worker Node Tạo EKS Cluster Tạo EKS Worker Node Tạo Elastic Container Registry Chạy Terraform để triển khai hạ tầng "
},
{
	"uri": "//localhost:1313/vi/4-cicd/4.4-argocd-autodeploy/",
	"title": "Cấu hình ArgoCD và Automation Deployment",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/5-devsecops/5.4-trivy-owasp-zap/",
	"title": "Cấu hình Trivy và OWASP ZAP",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/3-eks/3.4-eks-worker-node-create/",
	"title": "Tạo EKS Worker Node",
	"tags": [],
	"description": "",
	"content": "\nSSH Agent Forwading Như Architecture ở trên, ta có thể kết nối đến những EC2 Cluster thông qua Bastion Host. Tuy nhiên, ta không hề mong muốn Bastion Host chứa Private Key. Và thế là ta dùng SSH Agent Forwarding. Tại folder có chứa public key mà ta vừa tạo ở phần trước, thực hiện câu lệnh:\nssh-add EC2.pem Sau đó ta có thể kết nối với Bastion Host thông qua câu lệnh:\nssh -A ubuntu@\u0026lt;your-bastion-host-public-IP\u0026gt; Giờ ta đã kết nối thành công với Bastion Host. Giờ ta có thể kết nối đến EC2 Cluster thông qua câu lệnh sau:\nssh ec2-user@\u0026lt;your-EC2Cluster-private-IP\u0026gt; Kiểm tra Scaling Quay trở lại với Bastion Host, ta sẽ dùng Bastion Host để kiểm tra độ Scaling của các EC2 Cluster. Tất nhiên đây không phải là chức năng chính của Bastion Host, nhưng vì thuận tiện nên bạn đọc có thể dùng Bastion Host để gởi request đến Load Balancer và kiểm tra độ Scaling của EC2 Cluster.\n"
},
{
	"uri": "//localhost:1313/vi/2-vpc-ec2/2.2-jump-jenkins-sonar/2.2.4-sonar/",
	"title": "Tạo SonarQube Server",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/4-cicd/",
	"title": "Triển khai CI/CD Pipeline",
	"tags": [],
	"description": "",
	"content": "Dùng Terminal và trỏ vào thư mục chứa source code terraform ở trên. Thực hiện command line sau:\nterraform destroy Tất cả các tài nguyên sẽ được tự động dọn dẹp như hình bên dưới:\n"
},
{
	"uri": "//localhost:1313/vi/4-cicd/4.5-prometheus-grafana/",
	"title": "Cấu hình Prometheus và Grafana",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/2-vpc-ec2/2.2-jump-jenkins-sonar/2.2.5-run-terraform/",
	"title": "Chạy Terraform để triển khai hạ tầng",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/3-eks/3.5-ecr/",
	"title": "Tạo Elastic Container Registry",
	"tags": [],
	"description": "",
	"content": "\nSSH Agent Forwading Như Architecture ở trên, ta có thể kết nối đến những EC2 Cluster thông qua Bastion Host. Tuy nhiên, ta không hề mong muốn Bastion Host chứa Private Key. Và thế là ta dùng SSH Agent Forwarding. Tại folder có chứa public key mà ta vừa tạo ở phần trước, thực hiện câu lệnh:\nssh-add EC2.pem Sau đó ta có thể kết nối với Bastion Host thông qua câu lệnh:\nssh -A ubuntu@\u0026lt;your-bastion-host-public-IP\u0026gt; Giờ ta đã kết nối thành công với Bastion Host. Giờ ta có thể kết nối đến EC2 Cluster thông qua câu lệnh sau:\nssh ec2-user@\u0026lt;your-EC2Cluster-private-IP\u0026gt; Kiểm tra Scaling Quay trở lại với Bastion Host, ta sẽ dùng Bastion Host để kiểm tra độ Scaling của các EC2 Cluster. Tất nhiên đây không phải là chức năng chính của Bastion Host, nhưng vì thuận tiện nên bạn đọc có thể dùng Bastion Host để gởi request đến Load Balancer và kiểm tra độ Scaling của EC2 Cluster.\n"
},
{
	"uri": "//localhost:1313/vi/5-devsecops/",
	"title": "Triển khai DevSecOps",
	"tags": [],
	"description": "",
	"content": "Dùng Terminal và trỏ vào thư mục chứa source code terraform ở trên. Thực hiện command line sau:\nterraform destroy Tất cả các tài nguyên sẽ được tự động dọn dẹp như hình bên dưới:\n"
},
{
	"uri": "//localhost:1313/vi/4-cicd/4.6-efk/",
	"title": "Cấu hình EFK Stack",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/3-eks/3.6-run-terraform/",
	"title": "Tạo EKS Worker Node",
	"tags": [],
	"description": "",
	"content": "\nSSH Agent Forwading Như Architecture ở trên, ta có thể kết nối đến những EC2 Cluster thông qua Bastion Host. Tuy nhiên, ta không hề mong muốn Bastion Host chứa Private Key. Và thế là ta dùng SSH Agent Forwarding. Tại folder có chứa public key mà ta vừa tạo ở phần trước, thực hiện câu lệnh:\nssh-add EC2.pem Sau đó ta có thể kết nối với Bastion Host thông qua câu lệnh:\nssh -A ubuntu@\u0026lt;your-bastion-host-public-IP\u0026gt; Giờ ta đã kết nối thành công với Bastion Host. Giờ ta có thể kết nối đến EC2 Cluster thông qua câu lệnh sau:\nssh ec2-user@\u0026lt;your-EC2Cluster-private-IP\u0026gt; Kiểm tra Scaling Quay trở lại với Bastion Host, ta sẽ dùng Bastion Host để kiểm tra độ Scaling của các EC2 Cluster. Tất nhiên đây không phải là chức năng chính của Bastion Host, nhưng vì thuận tiện nên bạn đọc có thể dùng Bastion Host để gởi request đến Load Balancer và kiểm tra độ Scaling của EC2 Cluster.\n"
},
{
	"uri": "//localhost:1313/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]